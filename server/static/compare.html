<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MGSA Compare</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg: #0b1020;
      --panel: rgba(255,255,255,0.08);
      --panel2: rgba(255,255,255,0.06);
      --stroke: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --shadow: 0 20px 50px rgba(0,0,0,0.35);
      --shadow2: 0 10px 24px rgba(0,0,0,0.25);
      --radius: 16px;

      /* “yellow point” accent vibe */
      --accent: #ffd24a;
      --accent2: #ff9f1a;
      --good: #2ee59d;
      --bad: #ff5c7a;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--text);
      background:
        radial-gradient(900px 700px at 30% 15%, rgba(255,210,74,0.18), transparent 60%),
        radial-gradient(700px 600px at 80% 60%, rgba(46,229,157,0.12), transparent 60%),
        radial-gradient(900px 800px at 10% 85%, rgba(255,92,122,0.10), transparent 55%),
        linear-gradient(180deg, #070a14, #0b1020 40%, #070a14);
    }

    .wrap {
      display: grid;
      grid-template-columns: 1.25fr 0.75fr;
      height: 100vh;
    }

    /* Map side */
    #map { height: 100vh; }
    .leaflet-container {
      background: #0b0f1d;
    }
    .leaflet-control-zoom, .leaflet-bar {
      border: 1px solid rgba(255,255,255,0.12) !important;
      border-radius: 12px !important;
      overflow: hidden;
      box-shadow: var(--shadow2);
      backdrop-filter: blur(10px);
    }
    .leaflet-bar a {
      background: rgba(255,255,255,0.08) !important;
      color: var(--text) !important;
      border-bottom: 1px solid rgba(255,255,255,0.10) !important;
    }
    .leaflet-bar a:hover {
      background: rgba(255,255,255,0.14) !important;
    }
    .leaflet-control-attribution {
      background: rgba(0,0,0,0.35) !important;
      color: rgba(255,255,255,0.7) !important;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 4px 8px !important;
      backdrop-filter: blur(8px);
    }

    /* Right panel */
    .panel {
      padding: 16px;
      overflow: auto;
      border-left: 1px solid rgba(255,255,255,0.10);
      background:
        radial-gradient(700px 500px at 50% 0%, rgba(255,210,74,0.10), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      backdrop-filter: blur(10px);
    }

    /* Header row */
    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: var(--radius);
      box-shadow: var(--shadow2);
    }

    input, button {
      font-size: 14px;
      padding: 10px 12px;
      border-radius: 12px;
      outline: none;
      border: 1px solid rgba(255,255,255,0.12);
    }

    input {
      color: var(--text);
      background: rgba(255,255,255,0.06);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
      transition: border-color .15s ease, transform .15s ease, background .15s ease;
    }
    input::placeholder { color: rgba(255,255,255,0.45); }
    input:focus {
      border-color: rgba(255,210,74,0.55);
      background: rgba(255,255,255,0.08);
      transform: translateY(-1px);
    }

    button {
      cursor: pointer;
      border: 1px solid rgba(255,210,74,0.55);
      color: #1a1405;
      background: linear-gradient(180deg, var(--accent), var(--accent2));
      box-shadow: 0 10px 22px rgba(255,210,74,0.16);
      transition: transform .12s ease, box-shadow .12s ease, filter .12s ease;
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 30px rgba(255,210,74,0.20);
      filter: brightness(1.02);
    }
    button:active { transform: translateY(0px) scale(0.99); }

    /* KPI grid */
    .kpi {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }

    .card {
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: var(--radius);
      padding: 12px;
      background: rgba(255,255,255,0.05);
      box-shadow: var(--shadow2);
      position: relative;
      overflow: hidden;
    }
    .card::before{
      content:"";
      position:absolute;
      inset: 0;
      background:
        radial-gradient(420px 220px at 0% 0%, rgba(255,210,74,0.14), transparent 55%),
        radial-gradient(420px 220px at 100% 0%, rgba(46,229,157,0.10), transparent 55%);
      opacity: 0.9;
      pointer-events:none;
    }
    .card > * { position: relative; }

    .big {
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.3px;
      line-height: 1.1;
      display: flex;
      align-items: baseline;
      gap: 8px;
    }
    .card div:last-child {
      color: var(--muted);
      font-size: 13px;
      margin-top: 6px;
    }

    /* Optional: small “badge” vibe for KPIs if you later add spans */
    .pill {
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.8);
    }

    /* Chart + tables */
    canvas { max-width: 100%; }

    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      margin-top: 10px;
      overflow: hidden;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.12);
    }

    thead th {
      position: sticky;
      top: 0;
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.85);
      border-bottom: 1px solid rgba(255,255,255,0.10);
      font-size: 12.5px;
      padding: 10px 10px;
      backdrop-filter: blur(10px);
      z-index: 1;
    }

    tbody td {
      border-bottom: 1px solid rgba(255,255,255,0.08);
      padding: 10px 10px;
      text-align: left;
      font-size: 13px;
      color: rgba(255,255,255,0.88);
    }

    tbody tr:hover td {
      background: rgba(255,255,255,0.05);
    }

    /* Nice scrollbars */
    .panel::-webkit-scrollbar { width: 10px; }
    .panel::-webkit-scrollbar-track { background: rgba(255,255,255,0.04); border-radius: 10px; }
    .panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.12); border-radius: 10px; }
    .panel::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.18); }

    /* Responsive */
    @media (max-width: 980px) {
      .wrap { grid-template-columns: 1fr; }
      #map { height: 55vh; }
      .panel { border-left: none; border-top: 1px solid rgba(255,255,255,0.10); }
    }

    /* Optional: make KPI cards “feel” clickable if later you add click handlers */
    .card { transition: transform .12s ease, border-color .12s ease, background .12s ease; }
    .card:hover { transform: translateY(-1px); border-color: rgba(255,210,74,0.22); background: rgba(255,255,255,0.06); }

    /* =======================
      MGSA BRANDING
      ======================= */

    .mgsa-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 14px;
      padding: 14px 16px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.12);
      background:
        radial-gradient(400px 140px at 15% 0%, rgba(255,210,74,0.20), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      box-shadow: 0 14px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(12px);
    }

    .mgsa-logo {
      display: flex;
      flex-direction: column;
      line-height: 1.1;
    }

    .mgsa-accent {
      font-size: 26px;
      font-weight: 900;
      letter-spacing: 2px;
      background: linear-gradient(180deg, #ffd24a, #ff9f1a);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 6px 18px rgba(255,210,74,0.25);
    }

    .mgsa-sub {
      font-size: 11px;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.65);
      margin-top: 2px;
    }

    .mgsa-tag {
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 1.4px;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,210,74,0.45);
      color: #1a1405;
      background: linear-gradient(180deg, #ffd24a, #ff9f1a);
      box-shadow: 0 8px 20px rgba(255,210,74,0.25);
    }

    /* =======================
      SUBTLE MGSA WATERMARK
      ======================= */

    .panel::after {
      content: "MGSA";
      position: fixed;
      right: 24px;
      bottom: 18px;
      font-size: 96px;
      font-weight: 900;
      letter-spacing: 6px;
      color: rgba(255,255,255,0.035);
      pointer-events: none;
      user-select: none;
    }

  </style>

</head>
<body>
  <div class="wrap">
    <div id="map"></div>

    <div class="panel">
      <div class="row">
        <input id="baseUrl" value="http://localhost:8000" style="width: 220px;">
        <input id="trackId" value="mytrack" style="width: 120px;">
        <input id="driverKind" value="driver" style="width: 120px;">
        <input id="token" placeholder="Bearer token" style="width: 280px;">
        <button id="btnLoad">Load</button>
      </div>

      <div class="mgsa-header">
        <div class="mgsa-logo">
          <span class="mgsa-accent">MGSA</span>
          <span class="mgsa-sub">Motorsport Grand Slam Assistant</span>
        </div>
        <div class="mgsa-tag">COMPARE</div>
      </div>


      <div class="kpi">
        <div class="card">
          <div class="big" id="kpiTotalLoss">-</div>
          <div>Total time loss (s)</div>
        </div>
        <div class="card">
          <div class="big" id="kpiP95">-</div>
          <div>P95 error (m)</div>
        </div>
        <div class="card">
          <div class="big" id="kpiMean">-</div>
          <div>Mean error (m)</div>
        </div>
        <div class="card">
          <div class="big" id="kpiMax">-</div>
          <div>Max error (m)</div>
        </div>
      </div>

      <div class="card" style="margin-top: 12px;">
        <div style="font-weight:700; margin-bottom:8px;">Time loss by distance</div>
        <canvas id="chart" height="130"></canvas>
      </div>

      <div class="card" style="margin-top: 12px;">
        <div style="font-weight:700; margin-bottom:8px;">Top segments (most time loss)</div>
        <table>
          <thead>
            <tr>
              <th>Segment (m)</th>
              <th>Loss (s)</th>
              <th>Mean err (m)</th>
              <th>Max err (m)</th>
            </tr>
          </thead>
          <tbody id="segTable"></tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    let map = L.map('map');
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20 }).addTo(map);
    
    let layerOuter=null, layerInner=null, layerOpt=null, layerDrv=null;
    let chart=null;
    let wsRef = null;
    let pingTimer = null;
    
    function fmt(x, d=2){ return (x===null || x===undefined) ? "-" : Number(x).toFixed(d); }
    
    function splitByJumps(latlngs, jumpM = 12) {
      const R = 6371000;
      function dist(a,b){
        const lat1=a[0]*Math.PI/180, lat2=b[0]*Math.PI/180;
        const dlat=lat2-lat1, dlon=(b[1]-a[1])*Math.PI/180;
        const x = dlon*Math.cos((lat1+lat2)*0.5);
        const y = dlat;
        return Math.hypot(x,y)*R;
      }

      const parts = [];
      let cur = [];
      for (let i=0;i<latlngs.length;i++){
        if (cur.length && dist(cur[cur.length-1], latlngs[i]) > jumpM){
          parts.push(cur);
          cur = [];
        }
        cur.push(latlngs[i]);
      }
      if (cur.length) parts.push(cur);
      return parts;
    }

    function setPolyline(refs, latlngs, opts){
      // refs = array of layers
      if(refs) refs.forEach(l => map.removeLayer(l));
      const parts = splitByJumps(latlngs, 15);
      return parts.map(p => L.polyline(p, opts).addTo(map));
    }

    
    function csvToRows(csvText){
      const lines = csvText.trim().split(/\r?\n/);
      const hdr = lines[0].split(",");
      const rows = [];
      for(let i=1;i<lines.length;i++){
        const cols = lines[i].split(",");
        if(cols.length !== hdr.length) continue;
        const obj = {};
        for(let j=0;j<hdr.length;j++) obj[hdr[j]] = cols[j];
        rows.push(obj);
      }
      return { hdr, rows };
    }
    
    function toLatLngFromRows(rows, latKey, lonKey){
      return rows.map(r => [Number(r[latKey]), Number(r[lonKey])]);
    }
    
    function centerlineLatLng(boundRows){
      // center = 0.5*(outer + inner) in lat/lon space (good enough for visualization)
      return boundRows.map(r => {
        const lat = 0.5*(Number(r.outer_lat) + Number(r.inner_lat));
        const lon = 0.5*(Number(r.outer_lon) + Number(r.inner_lon));
        return [lat, lon];
      });
    }
    
    async function fetchText(url, headers){
      const resp = await fetch(url, { headers });
      if(!resp.ok) throw new Error(`HTTP ${resp.status}: ${await resp.text()}`);
      return await resp.text();
    }
    
    async function fetchJson(url, headers){
      const resp = await fetch(url, { headers });
      if(!resp.ok) throw new Error(`HTTP ${resp.status}: ${await resp.text()}`);
      return await resp.json();
    }
    
    function connectWS(){
      const baseUrl = document.getElementById("baseUrl").value.trim();
      const wsUrl = baseUrl.replace("http://","ws://").replace("https://","wss://") + "/ws/live";
    
      if(wsRef){
        try{ wsRef.close(); }catch(e){}
        wsRef = null;
      }
    
      const ws = new WebSocket(wsUrl);
      wsRef = ws;
    
      ws.onopen = () => {
        if(pingTimer) clearInterval(pingTimer);
        pingTimer = setInterval(() => { try{ ws.send("ping"); }catch(e){} }, 15000);
      };
    
      ws.onmessage = (ev) => {
        let msg = null;
        try{ msg = JSON.parse(ev.data); }catch(e){ return; }
        const trackId = document.getElementById("trackId").value.trim();
    
        if((msg.type === "driver_vs_optimal_ready" || msg.type === "optimal_ready") && msg.track_id === trackId){
          loadAll();
        }
      };
    
      ws.onclose = () => {
        if(pingTimer) { clearInterval(pingTimer); pingTimer = null; }
        setTimeout(connectWS, 1000);
      };
    }
    
    async function loadAll(){
      const baseUrl = document.getElementById("baseUrl").value.trim();
      const trackId = document.getElementById("trackId").value.trim();
      const driverKind = document.getElementById("driverKind").value.trim();
      const token = document.getElementById("token").value.trim();
    
      const headers = {
        ...(token ? {"Authorization": `Bearer ${token}`} : {})
      };
    
      // 1) boundaries (CSV)
      const boundCsv = await fetchText(`${baseUrl}/api/track/${encodeURIComponent(trackId)}/boundaries`, headers);
      const bound = csvToRows(boundCsv);
    
      const outer = toLatLngFromRows(bound.rows, "outer_lat", "outer_lon");
      const inner = toLatLngFromRows(bound.rows, "inner_lat", "inner_lon");
    
      layerOuter = setPolyline(layerOuter, outer, { weight: 4, color: "#FFD400", opacity: 0.9 });
      layerInner = setPolyline(layerInner, inner, { weight: 4, color: "#2E6BFF", opacity: 0.9 });

      const optCsv = await fetchText(
        `${baseUrl}/api/track/${encodeURIComponent(trackId)}/optimal_latlon.csv`,
        headers
      );
      const optRows = csvToRows(optCsv);
      const optLL = toLatLngFromRows(optRows.rows, "lat", "lon");

      layerOpt = setPolyline(layerOpt, optLL, {
        weight: 4,
        color: "#00C853",
        opacity: 0.95
      });


      // 2) driver line (CSV)
      const drvCsv = await fetchText(
        `${baseUrl}/api/track/${encodeURIComponent(trackId)}/racing_line/${encodeURIComponent(driverKind)}`,
        headers
      );

      const drv = csvToRows(drvCsv);
      const drvLL = toLatLngFromRows(drv.rows, "lat", "lon");
      layerDrv = setPolyline(layerDrv, drvLL, { weight: 4, color: "#FF1744", opacity: 0.95 });
    
      // fit bounds
      const allPts = outer.concat(inner).concat(optLL).concat(drvLL);
      map.fitBounds(L.latLngBounds(allPts));
    
      // 3) compare json (optional)
      try{
        const cmp = await fetchJson(`${baseUrl}/api/track/${encodeURIComponent(trackId)}/compare_driver_vs_optimal.json`, headers);
    
        document.getElementById("kpiTotalLoss").textContent = fmt(cmp.stats.total_time_loss_s, 3);
        document.getElementById("kpiP95").textContent       = fmt(cmp.stats.error_m.p95, 3);
        document.getElementById("kpiMean").textContent      = fmt(cmp.stats.error_m.mean, 3);
        document.getElementById("kpiMax").textContent       = fmt(cmp.stats.error_m.max, 3);
    
        const s = cmp.series.s_m;
        const tl = cmp.series.time_loss_s;
    
        const ctx = document.getElementById('chart');
        if(chart) chart.destroy();
        chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: s.map(x => Math.round(x)),
            datasets: [{
              label: 'time_loss_s (per step)',
              data: tl,
              tension: 0.2,
              pointRadius: 0
            }]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: true } },
            scales: { x: { display: false }, y: { beginAtZero: false } }
          }
        });
    
        const tbody = document.getElementById("segTable");
        tbody.innerHTML = "";

        const segs = (cmp.segments && cmp.segments.top) ? [...cmp.segments.top] : [];
        segs.sort((a, b) => Number(a.s0) - Number(b.s0));   // <-- ключът

        for(const seg of segs){
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${Math.round(seg.s0)}–${Math.round(seg.s1)}</td>
            <td>${fmt(seg.time_loss_s, 3)}</td>
            <td>${fmt(seg.mean_err_m, 3)}</td>
            <td>${fmt(seg.max_err_m, 3)}</td>
          `;
          tbody.appendChild(tr);
        }

      }catch(e){
        // compare json not generated yet -> just show map
        document.getElementById("kpiTotalLoss").textContent = "-";
        document.getElementById("kpiP95").textContent = "-";
        document.getElementById("kpiMean").textContent = "-";
        document.getElementById("kpiMax").textContent = "-";
        const tbody = document.getElementById("segTable");
        tbody.innerHTML = "";
        if(chart){ chart.destroy(); chart=null; }
      }
    }
    
    document.getElementById("btnLoad").addEventListener("click", () => {
      connectWS();
      loadAll();
    });
    </script>
    
</body>
</html>
